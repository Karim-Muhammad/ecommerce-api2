Real world example:

1. Ask to change password (POST /forgot-password) @body {email} - forgot password link under login form
2. Ask to enter email - user enters email
3. Send email with link to change password - user receives email with link
4. There are two options:
   1. link with token in query and user go to link and click on it - user clicks on link
   2. reset code in email and user copy it and paste it in the form application (/verify-reset-code) @body {code}
5. 1# option, server take token from query and verify it, then user can back to the form to enter new password, if token not verified (user didn't click on it), then user can't change password (no form to enter new password)
6. 2# option, application show form for reset-code to enter, after user enter code, server verify it and then user can enter new password
7. user enter new password and confirm (POST /reset-password) @body {password, confirm} - user enter new password and confirm

### Which is options is more secure?

The first option is more secure because the token is generated by the server and it's hard to guess. The second option is less secure because the reset code is sent to the user's email and it's easier to guess.

### it could anyone know the email, to use this link, so is it problem?

No, because the link is generated by the server and it's hard to guess. If the user didn't click on the link, then the token is not verified and the user can't change the password.

### Is Best Practise to put all tokens of user in User Schema (Same table)? or create another table for tokens of users?

Deciding whether to include `resetPasswordToken`, `resetPasswordExpires`, and `isVerified` in the `User` table or create a separate table depends on your application's complexity and specific requirements. Hereâ€™s a breakdown of both approaches:

### 1. **Storing in the `User` Table**

- **Advantages:**

  - **Simplicity:** Easier to implement and manage since everything is in one table.
  - **Faster Access:** No need to join tables or perform additional queries when verifying tokens or checking the verification status.
  - **Less Overhead:** Fewer tables mean simpler database schema and potentially better performance for smaller applications.

- **Disadvantages:**

  - **Schema Bloat:** Adding too many fields to the `User` table can make it cluttered, especially if you have more optional fields in the future.
  - **Not Scalable:** As your application grows, this approach might become unwieldy, especially if you introduce more complex token-based operations or want to track multiple tokens (e.g., for email verification, password reset, two-factor authentication).

- **Schema Example:**
  ```sql
  CREATE TABLE Users (
    id INT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    password_hash VARCHAR(255),
    resetPasswordToken VARCHAR(255),
    resetPasswordExpires DATETIME,
    isVerified BOOLEAN DEFAULT FALSE,
    ...
  );
  ```

### 2. **Creating a Separate `UserTokens` or `UserVerification` Table**

- **Advantages:**

  - **Modularity:** Separation of concerns makes the schema more organized and easier to maintain.
  - **Scalability:** Easier to extend and handle more complex scenarios, such as supporting multiple token types or tracking token usage history.
  - **Better Security:** Tokens can be managed and expired independently without directly affecting the `User` table.

- **Disadvantages:**

  - **Complexity:** Requires more sophisticated queries, possibly involving joins, and more database management.
  - **Performance:** In some cases, additional queries or joins might slightly impact performance, though this is usually minimal.

- **Schema Example:**

  ```sql
  CREATE TABLE UserTokens (
    id INT PRIMARY KEY,
    userId INT,
    token VARCHAR(255) UNIQUE,
    tokenType ENUM('passwordReset', 'emailVerification'),
    expires DATETIME,
    isUsed BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (userId) REFERENCES Users(id)
  );
  ```

  ```sql
  CREATE TABLE Users (
    id INT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    password_hash VARCHAR(255),
    isVerified BOOLEAN DEFAULT FALSE,
    ...
  );
  ```

### Recommendation:

For most applications, especially if they are not too complex, storing these fields in the `User` table is sufficient and straightforward. However, if you anticipate the need for a more complex token management system, or if you are building a large-scale application with high-security requirements, creating a separate table for tokens is a better long-term solution.

This approach also allows for more flexibility, such as storing multiple tokens, tracking token usage, or handling different types of tokens (e.g., for different verification processes).
